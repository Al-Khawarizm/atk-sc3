title:: Guide to ATK Matrix Files
summary:: A guide to reading, writing, and storing ATK matrices.
categories:: Libraries>Ambisonic Toolkit


SECTION:: Directory Structure

The ATK store assets in its Application Support directory:
code::
Atk.userSupportDir
::
This includes three default directories:
list::
##strong::kernels:: (FIR filters for kernel en/decoders),
##strong::sounds:: (example sound files in a-, b-format, and stereo),
##strong::matrices:: (for encoding, decoding, xforming).
::
These folders store the files shipped with the ATK. You can also optionally add your own strong::extensions:: folder, in which you can store kernels and matrices of your own design.  Note this is different from SuperCollider's strong::Extensions:: folder. If you haven't yet added an strong::extensions:: directory, you can see where to put it by executing the following method:
code::
Atk.userExtensionsDir // view it
Atk.userExtensionsDir.openOS // open it... if it exists!
::

There's a handy method that will build it for you in the expected structure:
code::
Atk.createExtensionsDir
::

This will create a directory structure that lives in your next to your default ATK assets. Note this creates both a strong::matrices:: folder structure, and an identical strong::kernels:: folder structure for storing your custom kernels.  The full structure will look like this:
tree::
  ## teletype::Application Support::
  tree::
    ## teletype::ATK::
    tree::
      ## teletype::kernels::  (ATK default)
      ## teletype::matrices::  (ATK default)
      ## teletype::sounds::  (ATK default)
      ## teletype::extensions::  (your custom additions)
      tree::
        ## teletype::kernels::
        tree::
          ##teletype::FOA::
          tree::
            ##teletype::decoders::
            ##teletype::encoders::
            ##teletype::xformers::
          ::
          ##teletype::HOA1::
          ##teletype::HOA2::
          ##teletype::...::
          ##teletype::HOAN::
        ::
        ## teletype::matrices::
        tree::
          ##teletype::FOA::
          tree::
            ##teletype::decoders::
            tree::
              ##myDecoderMatrix.txt
              ##myDecoderMatrixForReaper.mosl.txt
              ##myDecoderMatrixWithMetadata.yml
            ::
            ##teletype::encoders::
            ##teletype::xformers::
          ::
          ##teletype::HOA1::
          ##teletype::HOA2::
          ##teletype::...::
          ##teletype::HOAN::
        ::
      ::
    ::
  ::
::
Each of the folders (strong::FOA>encoders::, strong::HOA5>decoders::, etc.) are empty and ready to store matrices (and kernels) for use with the ATK-sc and ATK-Reaper (more on that later). When you write a matrix using the ATK, it will store it in this directory structure by default, and will look here by default when asked to read in a matrix from file.

You can view this structure and any files you've stored there using the following method:
code::
Atk.postMyMatrixDir;					// the whole foa matrices hierarchy
Atk.postMyMatrixDir('encoders');	// foa encoders only
Atk.postMyMatrixDir('decoders');	// foa decoders only
Atk.postMyMatrixDir('xformers');	// foa xformers only
::

Each of these matrix subdirectories can have further subdirectories at your discretion, e.g. for particular projects or categories of matrices.

SECTION::Writing Matrices

We'll start by writing a matrix file.

Let's create a first order encoder matrix from a nine-point t-design. A t-design is a collection of points on a sphere thyat are uniformly distributed.

code::
(
// cartesian coordinates of the nine points
~cartCoords = [
  [ -0.61237243569579, 0.35355339059327, 0.70710678118655 ],
  [ 0.61237243569579, 0.35355339059327, 0.70710678118655 ],
  [ 0, -0.70710678118655, 0.70710678118655 ],
  [ -0.86602540378444, 0.5, 0 ],
  [ 0.86602540378444, 0.5, 0 ],
  [ 0, -1, 0 ],
  [ -0.61237243569579, 0.35355339059327, -0.70710678118655 ],
  [ 0.61237243569579, 0.35355339059327, -0.70710678118655 ],
  [ 0, -0.70710678118655, -0.70710678118655 ],
];

// convert to Spherical coordinates
~directions = ~cartCoords.collect({ |xyz|
  var spherical;
  spherical = Cartesian(*xyz).asSpherical;
  [spherical.theta, spherical.phi] // discard rho, we just need directions
});

// here's our (velocity) encoder matrix
~encoderMtx = FoaEncoderMatrix.newDirections(~directions);
)
::

This link::Classes/FoaEncoderMatrix:: is now ready to be used for encoding planewaves at those
niine uniformly distributed positions.  After all that work, I want to store my matrix to file for
use in the future, and to use in my ATK-Reaper plugins!

There are three available file formats, each with a special purpose:

list::
##code::.txt:: : the most basic text file, writing the raw matrix only.
##code::.yml:: : store the matrix along with metadata in a human readable format.
##code::.mosl.txt:: : a text file formatted for use with Atk-Reaper JS-plugins.
::

Let's write this encoder matrix out in all three formats:

code::
// .txt extension writes the matrix only
~encoderMtx.writeToFile("my9PointEncoder.txt");

// .yml writes metadata as well
~encoderMtx.writeToFile("my9PointEncoder.yml");

// .mosl.txt writes matrix only, single lines for Reaper to read
~encoderMtx.writeToFile("my9PointEncoder.mosl.txt");
::

Because I only specified a file name, not a full path, it will store the matrix in the default location.
We're writing an link::Classes/FoaEncoderMatrix::, ATK can infer that it's an strong::encoder:: in the strong::FOA:: family.
Therefore, the ATK knows to put it in: code::../extensions/matrices/FOA/encoders::.

Had I specified a full path instead, it would have saved to that location.

code::
Atk.postMyMatrixDir('encoders');  // Here are my encoders (defaults to showing the FOA family)
::

SUBSECTION::Writing Metadata

Because this matrix is somewhat unique, it would be helpful to provide a bit more information
about it for future reference. This is where the code::.yml:: file format comes in.

Note that the link::Classes/AtkMatrix/#-writeToFile:: method has some optional
arguments: code::note:: and code::attributeDictionary::. A code::note:: can be a
brief description, while an code::attributeDictionary:: is a Dictionary for storing any
info you'd like in the form of key:value pairs.

code::
(
// A 'note': a description or note about the matrix
~note = "This is a nine-point t-design encoder made for a matrix file writing demo.";

// A Dictionary of more metadata to add.
~properties =  (
	author: "Me, the Reader",
	dateCreated: Date.getDate.stamp,
	channelOrdering: 'FuMa',
	weighting: 'maxN',
	dirInputs: ~directions
);
)
::

NOTE::
If keys in the strong::attributeDictionary:: match instance variables of FoaEncoderMatrix,
they can be retrieved with getters once loaded from the file. This is the case for
strong::dirInputs:: specified in the code::~properties:: dictionary above. We'll see the effect this has below.
::

Now write this matrix and metadata to file...
Be sure to specify the code::.yml:: extension in order to write the metadata.
Set strong::overwrite = true:: to force overwrite the file we wrote before with
the same name and extension.

code::
(
~encoderMtx.writeToFile( "my9PointEncoder.yml",
  note: ~note,
  attributeDictionary: ~properties,
  overwrite: true
)
)
::

SUBSECTION:: Writing Raw Matrices
In the above examples, we've been reading/writing matrices encapsulated in the AtkMatrix classes.
When writing from these objects, some the information can be inferred from them,
such as the strong::family:: (order, e.g. code::'FOA'::, code::'HOA3'::, etc.) and strong::type::
of matrix (e.g. code::'encoder', 'decoder', 'xformer'::).
In the case of a raw matrix, this information can't be inferred and should be explicitly set when writing to file.

code::
// here's a raw A-to-B encoder matrix
~matrix = Matrix.with([
	[ 0.61237243569579, 0.61237243569579, 0.61237243569579, 0.61237243569579 ],
	[ 0.5, 0.5, -0.5, -0.5 ],
	[ 0.5, -0.5, 0.5, -0.5 ],
	[ 0.5, -0.5, -0.5, 0.5 ]
])
::

Metadata is useful to record more information about the matrix:

code::
(
~note = "A 4-channel A-to-B encoder matrix, in Front-Left-Up orientation.";

// A Dictionary of more metadata to add.
~properties =  (
	author: "Me, the Reader",
	dateCreated: Date.getDate.stamp,
	channelOrdering: 'FuMa',
	weighting: 'maxN',
	dirInputs: [ [ 0.78539816339745, 0.61547970867039 ], [ -0.78539816339745, -0.61547970867039 ], [ 2.3561944901923, -0.61547970867039 ], [ -2.3561944901923, 0.61547970867039 ] ]
);
)
::

Now be sure to list the proper info for the arguments when writing it to file.  This is how the ATK will know where to store the file by default (unless a full path is provided to the file name argument).

code::
(
~matrix.writeToFile( "myA2B_flu_Matrix.yml", // be sure to use .yml for metadata
  'encoder',	// type
  'foa',			// family
  ~note,
  ~properties
)
)
::

There it is:
code::
Atk.postMyMatrixDir('encoders');
::

SUBSECTION:: Organizing your matrices

If you'll be generating many matrices, it's advisable to organize your matrices into
subfolders. For example, if you're algorithmically generating hundreds of matrices
for a particular project or process, it makes sense to store them in a subfolder.

To do this, you can create subfolders within your code::/encoders::, code::/decoders::,
and code::/xformers:: folders.

code::
// Store your encoder matrix with the other encoders, which live here:
Atk.getMatrixExtensionPath(\encoders, \foa);

// You can make subfolder for a group of matrices, say, for a particular project:
(
~projSubFolderName = "myProject";

File.mkdir( Atk.getMatrixExtensionPath(\encoders, \foa).fullPath +/+ ~projSubFolderName )
)

// For convenience, we'll the 9-point encoder matrix
// created above to your new project folder
::

NOTE:: Remember that because code::~encoderMtx:: is an link::Classes/FoaEncoderMatrix::,
the strong::type:: and strong::family:: arguments are inferred.
::

code::
(
~encoderMtx.writeToFile(~projSubFolderName +/+ "projectEncoder1.yml",
 note: ~note,
  attributeDictionary: ~properties
)
)

// there it is, in the 'myProject' subdirectory
Atk.postMyMatrixDir('encoders', 'foa')
::

Later you'll use link::Classes/FoaEncoderMatrix:: to read the file back in. ATK will know where to look
so you can simply specify the path relative to your subfolder:

code::
~encMatrix = FoaEncoderMatrix.newFromFile(~projSubFolderName +/+ "projectEncoder1.yml");

~encMatrix.info;
::

SECTION:: Reading Matrices

We wrote three encoder matrix files earlier, lets read them in.  As when writing, the ATK looks in your strong::extensions/matrices:: directory by default. So unless your matrix file is somewhere outside the defualt location, a filename will suffice to read it in, as the type (code::'encoder'::, code::'decoder'::, code::'xformer'::) is inferred from the object you're instantiating.

You can even omit the file extension if you don't think there will be multiple file types stored under the same name:

code::
~encoderMtx = FoaEncoderMatrix.newFromFile("my9PointEncoder")
// >> ERROR: it sees we have more than one file of that name
::

So we'll need to specify the extension...  Have a look at what each file type gives us back:

code::.txt:: format:
code::
// reading the .txt file, we just get a matrix and basic info
~encoderMtx = FoaEncoderMatrix.newFromFile("my9PointEncoder.txt");

// all the standard instance vars are preserved
~encoderMtx.matrix;
~encoderMtx.kind;				// defaults to filename
~encoderMtx.dirOutputs;	// inf, by nature of being an encoder
~encoderMtx.dirInputs;		// with no metadata, we can't know input directions, so 'implicit'
~encoderMtx.dim;
::

code::.mosl.txt:: format:
code::
// reading the mosl.txt file, we just get a matrix and basic info
~encoderMtx = FoaEncoderMatrix.newFromFile("my9PointEncoder.mosl.txt");

// all the standard instance vars are preserved
~encoderMtx.matrix;
~encoderMtx.kind;				// defaults to filename
~encoderMtx.dirOutputs;	// inf, by nature of being an encoder
~encoderMtx.dirInputs;		// with no metadata, we can't know input directions
~encoderMtx.dim;
::

code::.yml:: format:
code::
// reading the .yml file, we get the matrix plus metadata
~encoderMtx = FoaEncoderMatrix.newFromFile("my9PointEncoder.yml");

// all the standard instance vars are preserved
~encoderMtx.matrix;
~encoderMtx.kind;
~encoderMtx.dirOutputs;
~encoderMtx.dim;

// NOTE: because we provided the 'dirInputs' to the attributeDictionary
// when we wrote it to file, we now have that info for reference. Useful!
~encoderMtx.dirInputs;


// plus the other data you wrote to it:
~encoderMtx.info;  // formatted post
~encoderMtx.fileParse; // for direct access to the dictionary of values
~encoderMtx.fileParse.note; // What was this matrix again?? Oh yea...
// metadata loaded as an IndentityDictionary, so values can be accessed as pseudo-methods
~encoderMtx.fileParse.channelOrdering;
~encoderMtx.fileParse.keysValuesDo{|k,v| postf("% : %\n", k, v)};
::


SUBSECTION:: Test Case: creating a decoder from an FoaEncoderMatrix

We've now created a new FoaEncoderMatrix by reading in the file containing the matrix that we originally built using the FoaEncoderMatrix planewave encoder: *newDirections (using the points on a nine-point t-design).
As it turns out, an encoder matrix made from link::Classes/FoaEncoderMatrix#*newDirections:: is suitable for building a strong::decoder:: of the same geometry.
This involves performing the link::Classes/Matrix#-pseudoInverse:: on the encoder Matrix.

code::
~matrix = ~encoderMtx.matrix;	// retrieve the Matrix object stored in the FoaEncoderMatrix
~pinv = ~matrix.pseudoInverse;	// perform the pseudoinverse on that matrix to give decoding coefficients

// this decoder will output a velocity ("strict soundfield", max-rV) decode
// to speakers (or further spatial encoding) positioned in the following location (in this order)
~encoderMtx.dirInputs.do{|azElPairs, i| postf("chan %: %\n", i, azElPairs.raddeg) }
::

NOTE::
Because we're inverting an encoder to produce a decoder, the original emphasis::input directions:: of the strong::encoder::
will now be the emphasis::output directions:: of the strong::decoder::.
The channel ordering will be in the same order the input directions were specified in the encoder.
Therefore, in the above code we query the emphasis::encoder:: for its  code::dirInputs::  to know where our output channel signals are expected to be sent (in space!).
::

code::
~decoderDef = SynthDef(\pinv_decoder, { arg outbus=0, amp=1;
	var foa, decoder;

	// test signal: panning noise
	foa = FoaPanB.ar( PinkNoise.ar, LFSaw.kr( 12.reciprocal, 1 ), 0 );

	// because the pseudoinverse matrix is a raw Matrix,
	// we use AtkMatrixMix to decoder our b-format signal
	decoder = AtkMatrixMix.ar(foa, ~pinv, amp);
	Out.ar(outbus, decoder);
}).load(Server.default);

~decoder = Synth(\pinv_decoder, [\outbus, 0, \amp, -8.dbamp] )
~decoder.free;
::

TODO:
Investigate the resulting coefficients of decoders created from 3 different methods:
list::
##link::Classes/FoaDecoderMatrix#*newPeri:: in a cube format (reference 1)
##link::Classes/FoaDecoderMatrix#*newDiammetric:: in a cube format (reference 2)
##link::Classes/Matrix#-pseudoinverse:: in a cube format (test case)
::
- at the very least reference 1 & 2 should be identical (otherwise there's a bug)

	- if the pseudoinverse produces the same coefficients, great, that's the velocity decoder

	- - however, there's likely a gain factore that needs to be applied, either a scalar related to the number of "speakers" (9 in this case), or a common scaling factor like 2.sqrt/2, etc.

	- double-check the note about querying the dirInputs above, is this correct?

	- ALSO, submit bug that Matrix class needs documentation

	- ALSO, check for quaternion support in MathLib and square it with ArduinoQuaternion

	- TODO: group .postMyMatrixDir by files and directories so it's more readable

Compare
